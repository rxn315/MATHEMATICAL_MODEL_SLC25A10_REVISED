% ===========================================
% Local Sensitivity Analysis (UPDATED REA model)
% TP is FIXED (not a parameter)
% Params: [Ts_max, Tm_max, Ks_m, Km_m, Kp_m, lambda21, lambda31]
% ===========================================

clear; clc; close all;

% Load experimental competition data
load('Palmier_DIC_Competition_Exp_Data.mat');  % provides M_with_S, etc.

% ---------- Fixed phosphate capacity ----------
TP_FIXED = 70;   % fixed T^p_max in the same REA flux units as Ts_max, Tm_max

% ---------- Parameter names (7 parameters; TP removed) ----------
param_names = { ...
    'T^{s}_{max}', 'T^{m}_{max}', ...
    'K^{s}_{m}',   'K^{m}_{m}',   'K^{p}_{m}', ...
    '\lambda_{21}', '\lambda_{31}'};

n_params = numel(param_names);

% Preallocate matrix to store LSCs for each experiment
n_pts = numel(M_with_S);
LSC_MATRIX = zeros(n_pts, n_params);

% ---------- Baseline parameter vector ----------
% Order: [Ts_max, Tm_max, Ks_m, Km_m, Kp_m, lambda21, lambda31]
params0 = [70, 70, 1.17, 0.23, 0.93, 1.0, 1.0];

% ---------- Finite-difference perturbation ----------
perturbation = 0.01;  % Â±1%

% ---------- Loop over each experimental condition ----------
for j = 1:n_pts

    % Initial conditions for experiment j (match your dataset usage)
    Pm   = 11;
    Sm   = 1;
    Mm   = 1;
    Pims = 0;
    Sims = 0.5;

    % Keep your original choice (if your x-axis is reciprocal)
    Mims = 1 / M_with_S(j);
    % If not reciprocal, use: Mims = M_with_S(j);

    % State vector: [Mm, Mims, Sm, Sims, Pm, Pims]
    y0 = [Mm, Mims, Sm, Sims, Pm, Pims];

    % Compute baseline fluxes (UPDATED REA model)
    [J_succ, J_mal, J_pho] = compute_flux_REA_UPDATED(y0, params0, TP_FIXED);

    % ---------- Choose which flux to analyze ----------
    J_base = J_succ;        % <- succinate reverse-leg output (updated convention)
    % J_base = J_mal;       % <- malate reverse-leg output
    % J_base = J_pho;       % <- phosphate reverse-leg output

    % Avoid division by ~0
    if abs(J_base) < 1e-12
        LSC_MATRIX(j,:) = NaN;
        continue;
    end

    % Allocate vector for LSCs in this condition
    LSC_vec = zeros(1, n_params);

    % Sensitivity analysis for each parameter
    for i = 1:n_params
        p_plus  = params0; p_plus(i)  = params0(i) * (1 + perturbation);
        p_minus = params0; p_minus(i) = params0(i) * (1 - perturbation);

        % Perturbed fluxes
        [J_plus,~, ~] = compute_flux_REA_UPDATED(y0, p_plus,  TP_FIXED);
        [Jsm, Jmm, Jpm] = compute_flux_REA_UPDATED(y0, p_minus, TP_FIXED);

        % Select J_plus / J_minus consistent with chosen J_base
        J_plus  = Jsp; J_minus = Jsm;   % succinate
        % J_plus = Jmp; J_minus = Jmm;  % malate
        % J_plus = Jpp; J_minus = Jpm;  % phosphate

        % Central finite difference derivative dJ/dp_i
        dJdpi = (J_plus - J_minus) / (2 * perturbation * params0(i));

        % Normalized local sensitivity coefficient
        LSC_vec(i) = (params0(i) / J_base) * dJdpi;
    end

    % Store LSCs for this condition
    LSC_MATRIX(j, :) = LSC_vec;
end

% Mean across all conditions
mean_LSCs_succ = mean(LSC_MATRIX, 1, 'omitnan');
save('LSCs_succ.mat','mean_LSCs_succ');

% ---------- Plot horizontal bar chart ----------
figure('Color','w');
barh(mean_LSCs);
set(gca, 'YTick', 1:n_params, 'YTickLabel', param_names, 'FontSize', 14);
xlabel('Normalized Sensitivity (LSC)', 'FontSize', 16);
ylabel('Parameters', 'FontSize', 16);
title('Mean Local Sensitivity Coefficients (UPDATED REA model, TP fixed)', 'FontSize', 18);
grid on;


% ==========================================================
% Flux computation function (UPDATED REA)
% Includes forward + reverse rates with the SAME denominator
% TP is FIXED (input argument)
% ==========================================================
function [J_succ, J_mal, J_pho, v1f_s, v1f_m, v2f_p, v1r_s, v1r_m, v2r_p] = ...
    compute_flux_REA_UPDATED(y, params, TP)

    % States
    Mm  = y(1); Mims = y(2);
    Sm  = y(3); Sims = y(4);
    Pm  = y(5); Pims = y(6);

    % Parameters
    Ts_max   = params(1);
    Tm_max   = params(2);
    Ks_m     = params(3);
    Km_m     = params(4);
    Kp_m     = params(5);
    lambda21 = params(6);
    lambda31 = params(7);

    % ---------- Updated saturation polynomials ----------
    delta1 = 1 + Sm/Ks_m   + Mm/Km_m   + Pm/Kp_m;
    delta2 = 1 + Sims/Ks_m + Mims/Km_m + Pims/Kp_m;

    % ---------- Updated phi (single phi) ----------
    denom_phi = (Sims + lambda21*Mims + lambda31*Pims);
    epsPhi = 1e-12;
    if abs(denom_phi) < epsPhi
        denom_phi = epsPhi;
    end
    phi = (Sm + lambda21*Mm + lambda31*Pm) / denom_phi;

    % ---------- Common denominator ----------
    Den = delta1 + phi*delta2;
    epsDen = 1e-12;
    if abs(Den) < epsDen
        Den = epsDen;
    end

    % ========================================
    % Forward-cycle rates (UPDATED REA)
    % ========================================
    v1f_s = Ts_max * (Sm  - phi*Sims) / (Ks_m * Den);
    v1f_m = Tm_max * (Mm  - phi*Mims) / (Km_m * Den);
    v2f_p = TP     * (phi*Pims - Pm)  / (Kp_m * Den);

    % ========================================
    % Reverse-cycle rates (UPDATED REA)
    % ========================================
    v1r_s = Ts_max * (phi*Sims - Sm)  / (Ks_m * Den);
    v1r_m = Tm_max * (phi*Mims - Mm)  / (Km_m * Den);
    v2r_p = TP     * (Pm - phi*Pims)  / (Kp_m * Den);

    % ========================================
    % Output conventions (match your updated Palmieri fitting code)
    % ========================================
    J_succ = v1r_s-v1f_s;
    J_mal  = v1r_m-v1f_m;
    J_pho  = J_succ+J_mal;          % reverse phosphate leg

    % If instead you want NET phosphate: uncomment the next line
    % J_pho = v2r_p - v2f_p;
end
