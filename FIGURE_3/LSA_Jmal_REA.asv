% ===========================================
% Local Sensitivity Analysis for J_mal (UPDATED REA model)
% TP is FIXED (NOT a parameter)
% Params: [Ts_max, Tm_max, Ks_m, Km_m, Kp_m, lambda21, lambda31]
% ===========================================
clear; clc; close all;

% Load Palmier competition data
load('Palmier_DIC_Competition_Exp_Data.mat');

% -----------------------------
% Fixed phosphate capacity (constant, not estimated)
% -----------------------------
TP_FIXED = 1.0;   % choose the value consistent with your REA flux units

% -----------------------------
% Parameters (NO TP)
% -----------------------------
param_names = { ...
    'T^{s}_{max}', 'T^{m}_{max}', ...
    'K^{s}_{m}',   'K^{m}_{m}',   'K^{p}_{m}', ...
    '\lambda_{21}','\lambda_{31}'};
n_params = numel(param_names);

% Baseline parameters:
% [Ts_max, Tm_max, Ks_m, Km_m, Kp_m, lambda21, lambda31]
params0 = [70, 70, 1.17, 0.23, 0.93, 1.0, 1.0];

% Finite-difference perturbation (Â±1%)
perturbation = 0.01;

% How many points to evaluate
n_pts = numel(M_with_S);

% Store sensitivity coefficients at each data point
LSC_MATRIX = zeros(n_pts, n_params);

% -----------------------------
% Sensitivity loop over data points
% -----------------------------
for j = 1:n_pts

    % Experimental conditions (your current choice)
    Pm   = 11;   Sm   = 1;   Mm   = 1;
    Pims = 0;
    Sims = 0.5;
    Mims = 1 / M_with_S(j);   % keep your original mapping

    y0 = [Mm, Mims, Sm, Sims, Pm, Pims];

    % Baseline flux (use UPDATED Palmier convention: J_mal = v1r_m)
    [~, J_mal_base, ~] = compute_flux_REA_UPDATED(y0, params0, TP_FIXED);

    % Avoid division by ~0 in normalization
    if abs(J_mal_base) < 1e-12
        LSC_MATRIX(j,:) = NaN;
        continue;
    end

    % Local Sensitivity Coefficients at this point
    LSC_vec = zeros(1, n_params);

    for i = 1:n_params
        p_plus  = params0; p_plus(i)  = params0(i) * (1 + perturbation);
        p_minus = params0; p_minus(i) = params0(i) * (1 - perturbation);

        % Perturbed fluxes
        [~, J_mal_plus,  ~] = compute_flux_REA_UPDATED(y0, p_plus,  TP_FIXED);
        [~, J_mal_minus, ~] = compute_flux_REA_UPDATED(y0, p_minus, TP_FIXED);

        % Central difference dJ/dp (relative step)
        dJdpi = (J_mal_plus - J_mal_minus) / (2 * perturbation * params0(i));

        % Normalized LSC = (p/J) * dJ/dp
        LSC_vec(i) = (params0(i) / J_mal_base) * dJdpi;
    end

    LSC_MATRIX(j,:) = LSC_vec;
end

% Mean LSC across points (ignore NaNs)
mean_LSCs_mal = mean(LSC_MATRIX, 1, 'omitnan');

save('LSCs_mal_UPDATED_noTP.mat', ...
     'mean_LSCs_mal','LSC_MATRIX','params0','TP_FIXED','perturbation');

% -----------------------------
% Plot
% -----------------------------
figure('Color','w');
barh(mean_LSCs_mal);
set(gca, 'YTick', 1:n_params, 'YTickLabel', param_names, 'FontSize', 14);
xlabel('Normalized Sensitivity (LSC) for J_{mal}', 'FontSize', 16);
ylabel('Parameters', 'FontSize', 16);
title('Mean Local Sensitivity Coefficients for Malate Flux (UPDATED REA, TP fixed)', 'FontSize', 18);
grid on;


% ==========================================================
% UPDATED REA flux computation (TP is FIXED input)
% Uses the UPDATED denominator + single phi:
%   delta1 = 1 + Sm/Ks + Mm/Km + Pm/Kp
%   delta2 = 1 + Sims/Ks + Mims/Km + Pims/Kp
%   phi    = (Sm + lambda21*Mm + lambda31*Pm) / (Sims + lambda21*Mims + lambda31*Pims)
%   Den    = delta1 + phi*delta2
%
% Output conventions (Palmier fitting convention):
%   J_succ = v1r_s
%   J_mal  = v1r_m
%   J_pho  = v2r_p
% ==========================================================
function [J_succ, J_mal, J_pho] = compute_flux_REA_UPDATED(y, params, TP)

    % States: [Mm, Mims, Sm, Sims, Pm, Pims]
    Mm   = y(1);  Mims = y(2);
    Sm   = y(3);  Sims = y(4);
    Pm   = y(5);  Pims = y(6);

    % Parameters
    Ts_max   = params(1);
    Tm_max   = params(2);
    Ks_m     = params(3);
    Km_m     = params(4);
    Kp_m     = params(5);
    lambda21 = params(6);
    lambda31 = params(7);

    % Saturation polynomials (ALL substrates on each side)
    delta1 = 1 + Sm./Ks_m   + Mm./Km_m   + Pm./Kp_m;
    delta2 = 1 + Sims./Ks_m + Mims./Km_m + Pims./Kp_m;

    % Phi term (single phi)
    denom_phi = (Sims + lambda21*Mims + lambda31*Pims);
    epsPhi = 1e-12;
    if abs(denom_phi) < epsPhi
        denom_phi = epsPhi;
    end
    phi = (Sm + lambda21*Mm + lambda31*Pm) / denom_phi;

    % Common denominator
    Den = (delta1 + phi*delta2);
    epsDen = 1e-12;
    if abs(Den) < epsDen
        Den = epsDen;
    end

    % Forward-cycle rates (kept for completeness; not used in Palmier convention outputs)
    v1f_s = Ts_max * (Sm  - phi*Sims) / (Ks_m * Den);
    v1f_m = Tm_max * (Mm  - phi*Mims) / (Km_m * Den);
    v2f_p = TP     * (phi*Pims - Pm)  / (Kp_m * Den);

    % Reverse-cycle rates
    v1r_s = Ts_max * (phi*Sims - Sm)  / (Ks_m * Den);
    v1r_m = Tm_max * (phi*Mims - Mm)  / (Km_m * Den);
    v2r_p = TP     * (Pm - phi*Pims)  / (Kp_m * Den);

    % Output conventions (Palmier fitting)
    J_succ = v1r_s - v1f_s;
    J_mal  = v1r_m - v1f_m;
    J_pho  = J_succ+J_mal;

    % If you ever want NET fluxes instead, use:
    % J_succ = v1r_s - v1f_s;
    % J_mal  = v1r_m - v1f_m;
    % J_pho  = v2r_p - v2f_p;
end
